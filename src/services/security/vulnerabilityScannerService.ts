import { pool } from '../../config/database';
import { redisClient } from '../../config/redis';
import { auditService } from '../audit/auditService';
import crypto from 'crypto';

interface Vulnerability {
  id: string;
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  location: string;
  recommendation: string;
  cve?: string;
}

interface ScanResult {
  scanId: string;
  timestamp: Date;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
}

class VulnerabilityScannerService {
  /**
   * Полное сканирование системы
   */
  async performFullScan(): Promise<ScanResult> {
    const scanId = crypto.randomUUID();
    const vulnerabilities: Vulnerability[] = [];

    // Сканирование различных компонентов
    vulnerabilities.push(...await this.scanDatabaseSecurity());
    vulnerabilities.push(...await this.scanAuthenticationSecurity());
    vulnerabilities.push(...await this.scanSessionSecurity());
    vulnerabilities.push(...await this.scanAPIKeySecurity());
    vulnerabilities.push(...await this.scanRateLimitConfiguration());
    vulnerabilities.push(...await this.scanPasswordPolicies());
    vulnerabilities.push(...await this.scanDependencies());
    vulnerabilities.push(...await this.scanHeaders());
    vulnerabilities.push(...await this.scanCORS());
    vulnerabilities.push(...await this.scanCSP());

    const summary = this.calculateSummary(vulnerabilities);

    const result: ScanResult = {
      scanId,
      timestamp: new Date(),
      vulnerabilities,
      summary
    };

    // Сохранение результатов сканирования
    await this.saveScanResult(result);

    return result;
  }

  /**
   * Сканирование безопасности БД
   */
  private async scanDatabaseSecurity(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Проверка слабых паролей в БД
    const weakPasswords = await pool.query(`
      SELECT COUNT(*) as count 
      FROM users 
      WHERE LENGTH(password_hash) < 60
    `);

    if (parseInt(weakPasswords.rows[0].count) > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'weak_password_hashing',
        severity: 'critical',
        description: `Found ${weakPasswords.rows[0].count} users with weak password hashing`,
        location: 'database.users',
        recommendation: 'Ensure all passwords use bcrypt with at least 12 rounds'
      });
    }

    // Проверка неверифицированных email
    const unverifiedEmails = await pool.query(`
      SELECT COUNT(*) as count 
      FROM users 
      WHERE email_verified = false AND created_at < NOW() - INTERVAL '7 days'
    `);

    if (parseInt(unverifiedEmails.rows[0].count) > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'unverified_accounts',
        severity: 'medium',
        description: `Found ${unverifiedEmails.rows[0].count} unverified accounts older than 7 days`,
        location: 'database.users',
        recommendation: 'Implement automatic cleanup of old unverified accounts'
      });
    }

    // Проверка старых сессий
    const oldSessions = await pool.query(`
      SELECT COUNT(*) as count 
      FROM user_sessions 
      WHERE last_activity < NOW() - INTERVAL '30 days'
    `);

    if (parseInt(oldSessions.rows[0].count) > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'stale_sessions',
        severity: 'low',
        description: `Found ${oldSessions.rows[0].count} sessions inactive for more than 30 days`,
        location: 'database.user_sessions',
        recommendation: 'Implement automatic session cleanup'
      });
    }

    return vulnerabilities;
  }

  /**
   * Сканирование безопасности аутентификации
   */
  private async scanAuthenticationSecurity(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Проверка пользователей без 2FA (если это критично)
    const no2FA = await pool.query(`
      SELECT COUNT(*) as count 
      FROM users u
      LEFT JOIN user_2fa_settings tfa ON u.id = tfa.user_id
      WHERE tfa.enabled IS NULL OR tfa.enabled = false
    `);

    if (parseInt(no2FA.rows[0].count) > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'missing_2fa',
        severity: 'medium',
        description: `${no2FA.rows[0].count} users without 2FA enabled`,
        location: 'authentication',
        recommendation: 'Encourage or enforce 2FA for all users'
      });
    }

    // Проверка множественных неудачных попыток входа
    const suspiciousLogins = await pool.query(`
      SELECT ip_address, COUNT(*) as attempts
      FROM login_attempts
      WHERE success = false AND attempted_at > NOW() - INTERVAL '1 hour'
      GROUP BY ip_address
      HAVING COUNT(*) > 10
    `);

    if (suspiciousLogins.rows.length > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'brute_force_attempts',
        severity: 'high',
        description: `Detected ${suspiciousLogins.rows.length} IPs with excessive failed login attempts`,
        location: 'authentication',
        recommendation: 'Review and potentially block these IPs'
      });
    }

    return vulnerabilities;
  }

  /**
   * Сканирование безопасности сессий
   */
  private async scanSessionSecurity(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Проверка сессий с подозрительной активностью
    const suspiciousSessions = await pool.query(`
      SELECT COUNT(*) as count
      FROM user_sessions
      WHERE ip_address IN (
        SELECT ip_address 
        FROM intrusion_attempts 
        WHERE created_at > NOW() - INTERVAL '24 hours'
      )
    `);

    if (parseInt(suspiciousSessions.rows[0].count) > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'suspicious_sessions',
        severity: 'high',
        description: `Found ${suspiciousSessions.rows[0].count} active sessions from IPs with intrusion attempts`,
        location: 'sessions',
        recommendation: 'Terminate these sessions and investigate'
      });
    }

    return vulnerabilities;
  }

  /**
   * Сканирование безопасности API ключей
   */
  private async scanAPIKeySecurity(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Проверка API ключей без ограничений
    const unlimitedKeys = await pool.query(`
      SELECT COUNT(*) as count
      FROM api_keys
      WHERE rate_limit IS NULL OR rate_limit > 10000
    `);

    if (parseInt(unlimitedKeys.rows[0].count) > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'unlimited_api_keys',
        severity: 'medium',
        description: `Found ${unlimitedKeys.rows[0].count} API keys without proper rate limits`,
        location: 'api_keys',
        recommendation: 'Set appropriate rate limits for all API keys'
      });
    }

    // Проверка старых неиспользуемых ключей
    const staleKeys = await pool.query(`
      SELECT COUNT(*) as count
      FROM api_keys
      WHERE last_used_at < NOW() - INTERVAL '90 days' OR last_used_at IS NULL
    `);

    if (parseInt(staleKeys.rows[0].count) > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'stale_api_keys',
        severity: 'low',
        description: `Found ${staleKeys.rows[0].count} API keys unused for more than 90 days`,
        location: 'api_keys',
        recommendation: 'Revoke unused API keys'
      });
    }

    return vulnerabilities;
  }

  /**
   * Сканирование конфигурации rate limiting
   */
  private async scanRateLimitConfiguration(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Проверка наличия rate limiting в Redis
    const rateLimitKeys = await redisClient.keys('rate_limit:*');
    
    if (rateLimitKeys.length === 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'missing_rate_limiting',
        severity: 'high',
        description: 'No active rate limiting detected',
        location: 'middleware',
        recommendation: 'Ensure rate limiting middleware is properly configured'
      });
    }

    return vulnerabilities;
  }

  /**
   * Сканирование политик паролей
   */
  private async scanPasswordPolicies(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Проверка пользователей, не менявших пароль более 90 дней
    const oldPasswords = await pool.query(`
      SELECT COUNT(*) as count
      FROM users
      WHERE password_changed_at < NOW() - INTERVAL '90 days' OR password_changed_at IS NULL
    `);

    if (parseInt(oldPasswords.rows[0].count) > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'old_passwords',
        severity: 'low',
        description: `${oldPasswords.rows[0].count} users haven't changed password in 90+ days`,
        location: 'authentication',
        recommendation: 'Implement password expiration policy'
      });
    }

    return vulnerabilities;
  }

  /**
   * Сканирование зависимостей (упрощенная версия)
   */
  private async scanDependencies(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // В реальности здесь должна быть интеграция с npm audit или Snyk
    // Для демонстрации добавим базовую проверку

    vulnerabilities.push({
      id: crypto.randomUUID(),
      type: 'dependency_scan_needed',
      severity: 'medium',
      description: 'Regular dependency scanning not configured',
      location: 'dependencies',
      recommendation: 'Integrate npm audit or Snyk for automated dependency scanning'
    });

    return vulnerabilities;
  }

  /**
   * Сканирование HTTP заголовков безопасности
   */
  private async scanHeaders(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Проверка наличия security headers (это нужно проверять на уровне middleware)
    // Для демонстрации добавим рекомендацию

    const requiredHeaders = [
      'X-Frame-Options',
      'X-Content-Type-Options',
      'X-XSS-Protection',
      'Strict-Transport-Security',
      'Content-Security-Policy'
    ];

    vulnerabilities.push({
      id: crypto.randomUUID(),
      type: 'security_headers_check',
      severity: 'low',
      description: 'Ensure all security headers are properly configured',
      location: 'middleware',
      recommendation: `Verify these headers are set: ${requiredHeaders.join(', ')}`
    });

    return vulnerabilities;
  }

  /**
   * Сканирование CORS конфигурации
   */
  private async scanCORS(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Проверка CORS конфигурации
    vulnerabilities.push({
      id: crypto.randomUUID(),
      type: 'cors_configuration',
      severity: 'medium',
      description: 'CORS configuration should be reviewed',
      location: 'middleware',
      recommendation: 'Ensure CORS only allows trusted origins'
    });

    return vulnerabilities;
  }

  /**
   * Сканирование CSP конфигурации
   */
  private async scanCSP(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Проверка CSP violations
    const cspViolations = await pool.query(`
      SELECT COUNT(*) as count
      FROM csp_violations
      WHERE created_at > NOW() - INTERVAL '24 hours'
    `);

    if (parseInt(cspViolations.rows[0].count) > 10) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        type: 'csp_violations',
        severity: 'medium',
        description: `${cspViolations.rows[0].count} CSP violations in last 24 hours`,
        location: 'csp',
        recommendation: 'Review and fix CSP violations'
      });
    }

    return vulnerabilities;
  }

  /**
   * Расчет сводки по уязвимостям
   */
  private calculateSummary(vulnerabilities: Vulnerability[]): ScanResult['summary'] {
    return {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter(v => v.severity === 'critical').length,
      high: vulnerabilities.filter(v => v.severity === 'high').length,
      medium: vulnerabilities.filter(v => v.severity === 'medium').length,
      low: vulnerabilities.filter(v => v.severity === 'low').length
    };
  }

  /**
   * Сохранение результатов сканирования
   */
  private async saveScanResult(result: ScanResult): Promise<void> {
    await pool.query(
      `INSERT INTO vulnerability_scans (scan_id, timestamp, vulnerabilities, summary)
       VALUES ($1, $2, $3, $4)`,
      [result.scanId, result.timestamp, JSON.stringify(result.vulnerabilities), JSON.stringify(result.summary)]
    );

    await auditService.log({
      userId: undefined,
      action: 'vulnerability_scan',
      resourceType: 'security',
      details: { scanId: result.scanId, summary: result.summary }
    });
  }

  /**
   * Получение последних результатов сканирования
   */
  async getLatestScan(): Promise<ScanResult | null> {
    const result = await pool.query(
      `SELECT * FROM vulnerability_scans ORDER BY timestamp DESC LIMIT 1`
    );

    if (result.rows.length === 0) {
      return null;
    }

    const row = result.rows[0];
    return {
      scanId: row.scan_id,
      timestamp: row.timestamp,
      vulnerabilities: JSON.parse(row.vulnerabilities),
      summary: JSON.parse(row.summary)
    };
  }

  /**
   * Получение истории сканирований
   */
  async getScanHistory(limit: number = 10): Promise<ScanResult[]> {
    const result = await pool.query(
      `SELECT * FROM vulnerability_scans ORDER BY timestamp DESC LIMIT $1`,
      [limit]
    );

    return result.rows.map(row => ({
      scanId: row.scan_id,
      timestamp: row.timestamp,
      vulnerabilities: JSON.parse(row.vulnerabilities),
      summary: JSON.parse(row.summary)
    }));
  }
}

export default new VulnerabilityScannerService();
